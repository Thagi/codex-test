"""Pydantic models describing GPT-to-GPT simulation payloads."""
from __future__ import annotations

from typing import List, Optional

from pydantic import BaseModel, Field, field_validator, model_validator

from .chat import ChatMessage, GraphSnapshot


class SimulationParticipant(BaseModel):
    """Configuration for a simulated GPT participant."""

    role: str = Field(description="Human readable role identifier for the agent")
    persona: Optional[str] = Field(
        default=None,
        description="Optional persona or background information that guides the agent.",
    )

    @field_validator("role")
    @classmethod
    def _validate_role(cls, value: str) -> str:
        if not value.strip():
            raise ValueError("role must not be empty")
        return value


class SimulationRequest(BaseModel):
    """Request body for initiating a GPT-to-GPT conversation."""

    turns: int = Field(gt=0, le=10, description="Number of dialogue turns to simulate")
    participants: List[SimulationParticipant] = Field(
        description="Ordered list of GPT agents participating in the dialogue."
    )
    context: Optional[str] = Field(
        default=None,
        description="Scenario or topic framing the conversation.",
    )

    @model_validator(mode="after")
    def _validate_participants(self) -> "SimulationRequest":
        if len(self.participants) < 2:
            raise ValueError("At least two participants are required for simulation")
        return self


class SimulationResponse(BaseModel):
    """Response returned after completing the simulation run."""

    messages: List[ChatMessage]
    summary: str
    graph: GraphSnapshot


class SimulationCommitRequest(BaseModel):
    """Payload for persisting simulated conversation into the live graph."""

    target_session_id: str = Field(description="Existing session identifier to update")
    messages: List[ChatMessage] = Field(
        description="Transcript generated by the simulation run."
    )
    summary: str = Field(description="Knowledge summary derived from the simulation")
    notes: Optional[str] = Field(
        default=None,
        description="Optional operator notes stored with the knowledge node.",
    )

    @field_validator("target_session_id")
    @classmethod
    def _validate_session(cls, value: str) -> str:
        if not value.strip():
            raise ValueError("target_session_id must not be empty")
        return value


class SimulationCommitResponse(BaseModel):
    """Response returned after the simulation transcript has been persisted."""

    session_id: str
    knowledge_id: str
    summary: str
    short_term_snapshot: List[ChatMessage]
